<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>网页版我的世界 (Three.js)</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: sans-serif; }
        #crosshair {
            position: absolute; top: 50%; left: 50%;
            width: 20px; height: 20px;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 20 20"><path d="M10 0v20M0 10h20" stroke="white" stroke-width="2"/></svg>');
            background-repeat: no-repeat; background-position: center;
            transform: translate(-50%, -50%);
            pointer-events: none; z-index: 10;
        }
        #instructions {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            background: rgba(0,0,0,0.5); color: white; cursor: pointer; z-index: 20;
        }
        #info {
            position: absolute; top: 10px; left: 10px; color: white;
            background: rgba(0,0,0,0.3); padding: 10px; border-radius: 5px; pointer-events: none;
        }
        .active { color: #00ff00; font-weight: bold; }
    </style>
</head>
<body>
    <div id="crosshair"></div>
    <div id="info">
        WASD移动 | 空格跳跃<br>
        左键: 破坏 | 右键: 放置<br>
        1-5: 切换方块颜色<br>
        当前方块: <span id="blockType">草地</span>
    </div>
    <div id="instructions">
        <h1>点击屏幕开始游戏</h1>
        <p>（按 ESC 退出鼠标锁定）</p>
    </div>

    <!-- 引入 Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.159.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.159.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // 1. 初始化场景
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB); // 天空蓝
        scene.fog = new THREE.Fog(0x87CEEB, 10, 80);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // 2. 灯光
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(50, 100, 50);
        dirLight.castShadow = true;
        scene.add(dirLight);

        // 3. 材质定义
        const materials = [
            new THREE.MeshLambertMaterial({ color: 0x559c46 }), // 1. 草地
            new THREE.MeshLambertMaterial({ color: 0x888888 }), // 2. 石头
            new THREE.MeshLambertMaterial({ color: 0x8b4513 }), // 3. 泥土
            new THREE.MeshLambertMaterial({ color: 0xa0522d }), // 4. 木头
            new THREE.MeshLambertMaterial({ color: 0xffd700 }), // 5. 黄金
        ];
        let currentMaterialIndex = 0;
        const materialNames = ["草地", "石头", "泥土", "木头", "黄金"];

        // 4. 世界生成
        const objects = []; // 存储所有可碰撞/交互的方块
        const geometry = new THREE.BoxGeometry(1, 1, 1);

        function createBlock(x, y, z, matIndex) {
            const material = materials[matIndex];
            const voxel = new THREE.Mesh(geometry, material);
            voxel.position.set(x, y, z);
            voxel.castShadow = true;
            voxel.receiveShadow = true;
            scene.add(voxel);
            objects.push(voxel);
            return voxel;
        }

        // 生成地板
        for (let x = -10; x < 10; x++) {
            for (let z = -10; z < 10; z++) {
                // 简单的地形生成
                const y = Math.floor(Math.random() * 2); 
                createBlock(x, y, z, y === 1 ? 0 : 2); // 随机草地或泥土
                // 基岩
                createBlock(x, -1, z, 1);
            }
        }

        // 5. 控制与移动
        const controls = new PointerLockControls(camera, document.body);
        const instructions = document.getElementById('instructions');

        instructions.addEventListener('click', () => controls.lock());
        controls.addEventListener('lock', () => instructions.style.display = 'none');
        controls.addEventListener('unlock', () => instructions.style.display = 'flex');

        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let canJump = false;
        let velocity = new THREE.Vector3();
        let direction = new THREE.Vector3();
        const prevTime = performance.now();

        const onKeyDown = (event) => {
            switch (event.code) {
                case 'ArrowUp': case 'KeyW': moveForward = true; break;
                case 'ArrowLeft': case 'KeyA': moveLeft = true; break;
                case 'ArrowDown': case 'KeyS': moveBackward = true; break;
                case 'ArrowRight': case 'KeyD': moveRight = true; break;
                case 'Space': if (canJump === true) velocity.y += 15; canJump = false; break;
                case 'Digit1': selectMaterial(0); break;
                case 'Digit2': selectMaterial(1); break;
                case 'Digit3': selectMaterial(2); break;
                case 'Digit4': selectMaterial(3); break;
                case 'Digit5': selectMaterial(4); break;
            }
        };

        const onKeyUp = (event) => {
            switch (event.code) {
                case 'ArrowUp': case 'KeyW': moveForward = false; break;
                case 'ArrowLeft': case 'KeyA': moveLeft = false; break;
                case 'ArrowDown': case 'KeyS': moveBackward = false; break;
                case 'ArrowRight': case 'KeyD': moveRight = false; break;
            }
        };

        document.addEventListener('keydown', onKeyDown);
        document.addEventListener('keyup', onKeyUp);

        function selectMaterial(index) {
            currentMaterialIndex = index;
            document.getElementById('blockType').innerText = materialNames[index];
        }

        // 6. 交互 (破坏与放置)
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        document.addEventListener('mousedown', (event) => {
            if (!controls.isLocked) return;

            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            const intersects = raycaster.intersectObjects(objects, false);

            if (intersects.length > 0) {
                const intersect = intersects[0];
                
                // 距离限制
                if (intersect.distance > 8) return;

                if (event.button === 0) { // 左键：破坏
                    scene.remove(intersect.object);
                    objects.splice(objects.indexOf(intersect.object), 1);
                } else if (event.button === 2) { // 右键：放置
                    const pos = intersect.point.clone().add(intersect.face.normal);
                    pos.divideScalar(1).floor().addScalar(0.5); // 网格对齐
                    
                    // 防止将方块放置在玩家身体内部
                    const playerPos = camera.position.clone();
                    // 简单的碰撞检测：如果新方块位置和玩家太近，不允许放置
                    if (Math.abs(playerPos.x - pos.x) < 0.8 && 
                        Math.abs(playerPos.z - pos.z) < 0.8 &&
                        Math.abs(playerPos.y - pos.y) < 1.5) {
                        return;
                    }

                    createBlock(pos.x, pos.y, pos.z, currentMaterialIndex);
                }
            }
        });

        // 7. 物理与渲染循环
        let prevLoopTime = performance.now();

        function animate() {
            requestAnimationFrame(animate);

            const time = performance.now();
            const delta = (time - prevLoopTime) / 1000;
            prevLoopTime = time;

            if (controls.isLocked) {
                // 简单的物理模拟
                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;
                velocity.y -= 30.0 * delta; // 重力 9.8 * mass

                direction.z = Number(moveForward) - Number(moveBackward);
                direction.x = Number(moveRight) - Number(moveLeft);
                direction.normalize();

                if (moveForward || moveBackward) velocity.z -= direction.z * 100.0 * delta;
                if (moveLeft || moveRight) velocity.x -= direction.x * 100.0 * delta;

                controls.moveRight(-velocity.x * delta);
                controls.moveForward(-velocity.z * delta);
                
                controls.getObject().position.y += (velocity.y * delta);

                // 地面碰撞检测 (简化版)
                if (controls.getObject().position.y < 2.5) {
                    velocity.y = 0;
                    controls.getObject().position.y = 2.5;
                    canJump = true;
                }
            }

            renderer.render(scene, camera);
        }

        // 初始化位置
        camera.position.set(0, 5, 0);
        animate();

        // 窗口大小调整
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>