<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ‰‹åŠ¿é­”æ³•é˜µ - Strange Magic</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', sans-serif; }
        
        #input_video { position: absolute; top: 0; left: 0; opacity: 0; pointer-events: none; }
        #output_canvas { display: block; width: 100vw; height: 100vh; }

        /* UI é¢æ¿ */
        #ui-panel {
            position: absolute; top: 20px; right: 20px;
            width: 260px; padding: 20px;
            background: rgba(10, 10, 20, 0.7);
            border: 1px solid rgba(255, 200, 100, 0.3);
            border-radius: 12px;
            backdrop-filter: blur(10px);
            color: #ffd700;
            font-family: 'Courier New', monospace;
            z-index: 100;
        }

        h2 { margin: 0 0 15px 0; font-size: 18px; text-transform: uppercase; letter-spacing: 2px; text-align: center; text-shadow: 0 0 10px #ffd700; }
        
        .control-group { margin-bottom: 15px; }
        label { display: block; font-size: 12px; opacity: 0.8; margin-bottom: 5px; }
        
        select, input[type="color"] {
            width: 100%; padding: 8px;
            background: rgba(0,0,0,0.5); border: 1px solid #ffd700;
            color: #ffd700; border-radius: 4px; outline: none;
        }
        
        #status { font-size: 12px; text-align: center; color: #00ffcc; margin-top: 10px; }

        #overlay {
            position: absolute; bottom: 30px; width: 100%; text-align: center;
            color: rgba(255, 215, 0, 0.8); font-size: 16px; pointer-events: none;
            text-shadow: 0 0 10px rgba(255, 100, 0, 0.5);
            font-family: 'Courier New', cursive;
        }
    </style>
</head>
<body>

    <video id="input_video" playsinline></video>
    
    <div id="ui-panel">
        <h2>Arcane Arts</h2>
        
        <div class="control-group">
            <label>MAGIC STYLE (æ³•é˜µæ ·å¼)</label>
            <select id="styleSelect">
                <option value="strange">Eldritch (ç§˜æœ¯é‡‘)</option>
                <option value="cyber">Cyberpunk (èµ›åšé’)</option>
                <option value="dark">Void (è™šç©ºç´«)</option>
            </select>
        </div>

        <div class="control-group">
            <label>CORE COLOR (æ ¸å¿ƒé¢œè‰²)</label>
            <input type="color" id="colorPicker" value="#ffaa00">
        </div>

        <div id="status">åˆå§‹åŒ–è§†è§‰ä¼ æ„Ÿå™¨...</div>
    </div>

    <div id="overlay">
        ğŸ– <b>å¼ å¼€æ‰‹æŒ</b> å¬å”¤æ³•é˜µ &nbsp;|&nbsp; âœŠ <b>æ¡æ‹³</b> å…³é—­æ³•é˜µ
    </div>

    <canvas id="output_canvas"></canvas>

    <!-- ä¾èµ–åº“ -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    
    <script type="module">
        import * as THREE from 'https://cdn.skypack.dev/three@0.136.0';

        // --- 1. é…ç½®ä¸çŠ¶æ€ ---
        const config = {
            baseColor: new THREE.Color(0xffaa00),
            smoothing: 0.15, // åŠ¨ä½œå¹³æ»‘åº¦
            scaleSpeed: 0.1
        };

        const handsData = {
            left: { visible: false, position: new THREE.Vector3(), rotation: new THREE.Quaternion(), open: 0 },
            right: { visible: false, position: new THREE.Vector3(), rotation: new THREE.Quaternion(), open: 0 }
        };

        // --- 2. çº¹ç†ç”Ÿæˆå™¨ (Procedural Textures) ---
        // ä½¿ç”¨ Canvas 2D ç»˜åˆ¶å¤æ‚çš„é­”æ³•å›¾æ¡ˆï¼Œä½œä¸ºçº¹ç†è´´å›¾
        function createMagicTexture(type) {
            const size = 512;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');
            const cx = size / 2;
            const cy = size / 2;

            ctx.strokeStyle = '#ffffff';
            ctx.fillStyle = '#ffffff';
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#ffffff';
            ctx.lineWidth = 3;

            if (type === 'ring_runes') {
                // å¤–åœˆç¬¦æ–‡
                ctx.beginPath();
                ctx.arc(cx, cy, 200, 0, Math.PI * 2);
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(cx, cy, 180, 0, Math.PI * 2);
                ctx.stroke();
                
                // ç»˜åˆ¶ç¬¦æ–‡æ–‡å­—
                ctx.font = '24px serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ123456789";
                const count = 24;
                for (let i = 0; i < count; i++) {
                    const angle = (i / count) * Math.PI * 2;
                    ctx.save();
                    ctx.translate(cx + Math.cos(angle) * 190, cy + Math.sin(angle) * 190);
                    ctx.rotate(angle + Math.PI / 2);
                    ctx.fillText(chars[i % chars.length], 0, 0);
                    ctx.restore();
                }
            } else if (type === 'geometry_square') {
                // å†…éƒ¨å‡ ä½•ï¼šä¸¤ä¸ªæ­£æ–¹å½¢æ—‹è½¬å åŠ 
                ctx.lineWidth = 4;
                const drawSquare = (rot) => {
                    ctx.save();
                    ctx.translate(cx, cy);
                    ctx.rotate(rot);
                    const r = 140;
                    ctx.beginPath();
                    ctx.moveTo(-r, -r);
                    ctx.lineTo(r, -r);
                    ctx.lineTo(r, r);
                    ctx.lineTo(-r, r);
                    ctx.closePath();
                    ctx.stroke();
                    ctx.restore();
                }
                drawSquare(0);
                drawSquare(Math.PI / 4);
                
                // å†…éƒ¨æ–‡å­—åœˆ
                ctx.beginPath();
                ctx.arc(cx, cy, 90, 0, Math.PI * 2);
                ctx.stroke();
            } else if (type === 'core_complex') {
                // æ ¸å¿ƒå›¾æ¡ˆ
                for(let i=0; i<3; i++) {
                    ctx.beginPath();
                    ctx.arc(cx, cy, 30 + i*20, 0, Math.PI * 2);
                    ctx.stroke();
                }
                // ç»˜åˆ¶ä¸‰è§’å½¢
                ctx.beginPath();
                ctx.moveTo(cx, cy - 60);
                ctx.lineTo(cx + 52, cy + 30);
                ctx.lineTo(cx - 52, cy + 30);
                ctx.closePath();
                ctx.stroke();
            }

            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            return texture;
        }

        // --- 3. é­”æ³•é˜µç±» (Magic Circle Object) ---
        class MagicCircle {
            constructor() {
                this.meshGroup = new THREE.Group();
                this.layers = [];
                this.currentScale = 0;
                this.targetScale = 0;

                // åˆ›å»ºä¸‰å±‚ä¸åŒçš„å›¾æ¡ˆ
                this.addLayer(createMagicTexture('ring_runes'), 2.0, 0.01);
                this.addLayer(createMagicTexture('geometry_square'), 1.4, -0.02);
                this.addLayer(createMagicTexture('core_complex'), 0.6, 0.04);

                scene.add(this.meshGroup);
            }

            addLayer(texture, size, rotSpeed) {
                const geometry = new THREE.PlaneGeometry(size, size);
                const material = new THREE.MeshBasicMaterial({
                    map: texture,
                    color: config.baseColor,
                    transparent: true,
                    opacity: 0.9,
                    side: THREE.DoubleSide,
                    blending: THREE.AdditiveBlending, // å…³é”®ï¼šåŠ æ³•æ··åˆå®ç°å‘å…‰æ„Ÿ
                    depthWrite: false
                });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.rotSpeed = rotSpeed;
                this.meshGroup.add(mesh);
                this.layers.push(mesh);
            }

            update(handData) {
                // å¹³æ»‘ä½ç½®
                this.meshGroup.position.lerp(handData.position, config.smoothing);
                
                // å¹³æ»‘æ—‹è½¬ (è·Ÿéšæ‰‹æŒæœå‘)
                this.meshGroup.quaternion.slerp(handData.rotation, config.smoothing);

                // çŠ¶æ€é€»è¾‘ï¼šæ‰‹å¼ å¼€åˆ™æ˜¾ç¤ºï¼Œæ‰‹æ¡æ‹³åˆ™æ¶ˆå¤±
                // handData.open æ˜¯ä¸€ä¸ª 0-1 çš„å€¼ï¼Œ1ä»£è¡¨å…¨å¼ å¼€
                const isOpen = handData.open > 0.6; 
                this.targetScale = isOpen ? 1 : 0;

                // åŠ¨æ€ç¼©æ”¾åŠ¨ç”»
                this.currentScale += (this.targetScale - this.currentScale) * config.scaleSpeed;
                this.meshGroup.scale.setScalar(this.currentScale);

                // è‡ªèº«æ—‹è½¬åŠ¨ç”»
                if (this.currentScale > 0.01) {
                    this.layers.forEach(layer => {
                        layer.rotation.z += layer.rotSpeed;
                    });
                }

                // é¢œè‰²æ›´æ–°
                this.layers.forEach(layer => {
                    layer.material.color.lerp(config.baseColor, 0.1);
                    // ç®€å•çš„é—ªçƒæ•ˆæœ
                    layer.material.opacity = 0.7 + Math.sin(Date.now() * 0.005) * 0.2;
                });
            }
        }

        // --- 4. Three.js åˆå§‹åŒ– ---
        const canvas = document.getElementById('output_canvas');
        const scene = new THREE.Scene();
        
        // æ‘„åƒæœºè®¾ç½®
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 0, 5); // ç¨å¾®ç¦»è¿œä¸€ç‚¹

        const renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);

        // åˆ›å»ºä¸¤ä¸ªé­”æ³•é˜µå®ä¾‹ï¼ˆå·¦å³æ‰‹ï¼‰
        const circleLeft = new MagicCircle();
        const circleRight = new MagicCircle();

        // --- 5. MediaPipe Hands å¤„ç†é€»è¾‘ ---
        const videoElement = document.getElementById('input_video');
        const statusEl = document.getElementById('status');

        function onResults(results) {
            // é‡ç½®çŠ¶æ€
            handsData.left.visible = false;
            handsData.right.visible = false;

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                results.multiHandLandmarks.forEach((landmarks, index) => {
                    // åˆ¤æ–­å·¦å³æ‰‹
                    const classification = results.multiHandedness[index];
                    const isRight = classification.label === 'Right'; // MediaPipeæ˜¯é•œåƒçš„ï¼Œé€šå¸¸è¿™é‡Œåç€æ¥ï¼Œæˆ–è€…æ ¹æ®æ‘„åƒå¤´é•œåƒè°ƒæ•´
                    const target = isRight ? handsData.right : handsData.left;
                    
                    target.visible = true;

                    // 1. è·å–ä½ç½® (ä½¿ç”¨æ‰‹æŒä¸­å¿ƒ: ç´¢å¼•0å’Œ9çš„ä¸­é—´)
                    const wrist = landmarks[0];
                    const middleMCP = landmarks[9];
                    
                    // åæ ‡è½¬æ¢ (MediaPipe 0-1 => Three.js è§†å£åæ ‡)
                    // x éœ€è¦åè½¬ (é•œåƒ)
                    const x = (-(wrist.x + middleMCP.x) / 2 + 0.5) * 8; // 8æ˜¯è§†å£å®½åº¦å€ç‡
                    const y = -((wrist.y + middleMCP.y) / 2 - 0.5) * 6; // 6æ˜¯è§†å£é«˜åº¦å€ç‡
                    const z = -landmarks[0].z * 10; // æ·±åº¦

                    target.position.set(x, y, z);

                    // 2. è®¡ç®—æ‰‹æŒå¼ å¼€ç¨‹åº¦ (è®¡ç®—æŒ‡å°–åˆ°æ‰‹è…•çš„å¹³å‡è·ç¦»)
                    // æ‹‡æŒ‡4, é£ŸæŒ‡8, ä¸­æŒ‡12, æ— åæŒ‡16, å°æŒ‡20
                    const tips = [4, 8, 12, 16, 20];
                    let totalDist = 0;
                    tips.forEach(idx => {
                        const tip = landmarks[idx];
                        totalDist += Math.sqrt(Math.pow(tip.x - wrist.x, 2) + Math.pow(tip.y - wrist.y, 2));
                    });
                    const avgDist = totalDist / 5;
                    // é˜ˆå€¼æ˜ å°„ï¼š<0.2 è®¤ä¸ºæ˜¯æ‹³å¤´, >0.35 è®¤ä¸ºæ˜¯å¼ å¼€
                    target.open = Math.min(Math.max((avgDist - 0.2) * 5, 0), 1); 

                    // 3. è®¡ç®—æ—‹è½¬ (æ ¹æ®æ‰‹æŒæ³•çº¿)
                    // ç®€å•åšæ³•ï¼šåˆ©ç”¨ Wrist(0), IndexMCP(5), PinkyMCP(17) æ„å»ºå¹³é¢
                    const p0 = new THREE.Vector3(landmarks[0].x, landmarks[0].y, landmarks[0].z);
                    const p5 = new THREE.Vector3(landmarks[5].x, landmarks[5].y, landmarks[5].z);
                    const p17 = new THREE.Vector3(landmarks[17].x, landmarks[17].y, landmarks[17].z);
                    
                    const v1 = new THREE.Vector3().subVectors(p5, p0);
                    const v2 = new THREE.Vector3().subVectors(p17, p0);
                    const normal = new THREE.Vector3().crossVectors(v1, v2).normalize();
                    
                    // å°†æ³•çº¿è½¬æ¢ä¸ºæ—‹è½¬å››å…ƒæ•° (ç›®æ ‡æ˜¯è®©å¹³é¢æœå‘æ³•çº¿)
                    // è¿™é‡Œç®€åŒ–ï¼šæˆ‘ä»¬å¸Œæœ›é­”æ³•é˜µå¹³é¢å¯¹é½æ‰‹æŒã€‚
                    // é­”æ³•é˜µé»˜è®¤æ˜¯XYå¹³é¢ã€‚
                    const dummyObj = new THREE.Object3D();
                    dummyObj.lookAt(normal.x, -normal.y, -normal.z); // ç®€å•çš„æ³•çº¿æœå‘ä¿®æ­£
                    target.rotation.copy(dummyObj.quaternion);
                });
                statusEl.innerText = "è¿½è¸ªä¸­ - æ–½å±•é­”æ³•å§ï¼";
                statusEl.style.color = "#00ffcc";
            } else {
                statusEl.innerText = "ç­‰å¾…æ‰‹éƒ¨è¿›å…¥è§†é‡...";
                statusEl.style.color = "#ffaa00";
            }
        }

        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});

        hands.setOptions({
            maxNumHands: 2,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 640, height: 480
        });
        cameraUtils.start();

        // --- 6. äº¤äº’ UI é€»è¾‘ ---
        document.getElementById('colorPicker').addEventListener('input', (e) => {
            config.baseColor.set(e.target.value);
        });

        document.getElementById('styleSelect').addEventListener('change', (e) => {
            const val = e.target.value;
            if(val === 'strange') config.baseColor.setHex(0xffaa00);
            if(val === 'cyber') config.baseColor.setHex(0x00ffff);
            if(val === 'dark') config.baseColor.setHex(0x9900ff);
            document.getElementById('colorPicker').value = '#' + config.baseColor.getHexString();
        });

        // --- 7. æ¸²æŸ“å¾ªç¯ ---
        function animate() {
            requestAnimationFrame(animate);

            // å¦‚æœæ²¡æœ‰æ£€æµ‹åˆ°æ‰‹ï¼Œä½ç½®ç¨å¾®å½’ä¸­ï¼Œä¸”è®©å…¶ä¸å¯è§(é€šè¿‡scaleæ§åˆ¶)
            if (!handsData.left.visible) handsData.left.open = 0;
            if (!handsData.right.visible) handsData.right.open = 0;

            circleLeft.update(handsData.left);
            circleRight.update(handsData.right);

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();

    </script>
</body>
</html>