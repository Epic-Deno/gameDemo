<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>王国之泪 - 网页迷你版</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #202020;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        #game-container {
            position: relative;
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.5);
            border-radius: 4px;
            overflow: hidden;
        }
        canvas {
            display: block;
            background-color: #63a940; /* 海拉鲁草地绿 */
            cursor: crosshair;
        }
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: none;
        }
        .heart {
            color: #ff3e3e;
            font-size: 24px;
            text-shadow: 2px 2px 0 #000;
            margin-right: 5px;
        }
        /* 注意：这里的 ID 是 start-screen */
        #start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #e3dec6;
            z-index: 10;
        }
        h1 {
            font-size: 48px;
            margin-bottom: 10px;
            color: #4bdfff; /* 佐纳乌绿 */
            text-shadow: 0 0 10px #4bdfff;
            font-family: serif;
        }
        p { font-size: 18px; line-height: 1.6; color: #ddd; }
        .btn {
            padding: 15px 40px;
            font-size: 24px;
            background: linear-gradient(45deg, #1c7a7a, #2ebfbf);
            color: white;
            border: 2px solid #fff;
            border-radius: 8px;
            cursor: pointer;
            margin-top: 30px;
            transition: transform 0.2s;
        }
        .btn:hover { transform: scale(1.05); }
        .controls {
            margin-top: 20px;
            font-size: 14px;
            color: #aaa;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    
    <div id="ui-layer">
        <div id="hearts-container"></div>
    </div>

    <!-- 这里的 ID 是 start-screen -->
    <div id="start-screen">
        <h1>王国之泪：网页试炼</h1>
        <p>探索海拉鲁，击败魔物，使用佐纳乌科技</p>
        <div class="controls">
            WASD / 方向键：移动<br>
            空格 / 鼠标左键：挥剑攻击<br>
            SHIFT (按住)：加速跑（消耗精力）<br>
            E 键：抓取/放下 物体 (究极手)
        </div>
        <button class="btn" id="startBtn">唤醒林克</button>
    </div>
</div>

<script>
/**
 * 游戏配置与全局变量
 */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// --- 修复点：确保 JS 获取的 ID 与 HTML 中的 id="start-screen" 一致 ---
const startScreen = document.getElementById('start-screen'); 
const heartsContainer = document.getElementById('hearts-container');

let gameRunning = false;
let lastTime = 0;
let keys = {};
let mouse = { x: 0, y: 0, down: false };

// 音频上下文
let audioCtx;

/**
 * 音频合成器 (无需外部文件)
 */
const AudioSys = {
    init: function() {
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        audioCtx = new AudioContext();
    },
    playTone: function(freq, type, duration, vol = 0.1) {
        if (!audioCtx) return;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
        
        gain.gain.setValueAtTime(vol, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);

        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start();
        osc.stop(audioCtx.currentTime + duration);
    },
    playSword: function() {
        this.playTone(600, 'sawtooth', 0.1, 0.1);
        setTimeout(() => this.playTone(400, 'sawtooth', 0.1, 0.1), 50);
    },
    playHit: function() {
        this.playTone(150, 'square', 0.2, 0.2);
    },
    playDash: function() {
        this.playTone(800, 'sine', 0.1, 0.05);
    },
    playUltrahand: function() { 
        this.playTone(1200, 'sine', 0.3, 0.05);
        this.playTone(1500, 'triangle', 0.3, 0.05);
    },
    startBGM: function() {
        // 简单的生成式背景氛围音 (模拟钢琴)
        setInterval(() => {
            if (!gameRunning) return;
            if (Math.random() < 0.1) {
                const notes = [261.63, 293.66, 329.63, 392.00, 440.00, 523.25]; // C大调五声
                const note = notes[Math.floor(Math.random() * notes.length)];
                this.playTone(note, 'sine', 1.5, 0.02);
            }
        }, 500);
    }
};

/**
 * 游戏实体类
 */
class Camera {
    constructor() {
        this.x = 0;
        this.y = 0;
    }
    follow(target) {
        // 简单的平滑跟随
        this.x += (target.x - canvas.width / 2 - this.x) * 0.1;
        this.y += (target.y - canvas.height / 2 - this.y) * 0.1;
    }
}

class Player {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.radius = 15;
        this.speed = 3;
        this.runSpeed = 5;
        this.color = '#2ecc71'; // 林克绿
        this.maxStamina = 100;
        this.stamina = 100;
        this.maxHealth = 5;
        this.health = 5;
        this.angle = 0;
        
        this.attacking = false;
        this.attackTimer = 0;
        
        this.holdingItem = null; // 究极手抓取的物体
    }

    update() {
        // 移动逻辑
        let dx = 0;
        let dy = 0;
        let currentSpeed = this.speed;

        // Shift 加速
        if (keys['ShiftLeft'] && (keys['KeyW'] || keys['KeyA'] || keys['KeyS'] || keys['KeyD'])) {
            if (this.stamina > 0) {
                currentSpeed = this.runSpeed;
                this.stamina -= 1;
            }
        } else {
            if (this.stamina < this.maxStamina) this.stamina += 0.5;
        }

        if (keys['KeyW'] || keys['ArrowUp']) dy = -1;
        if (keys['KeyS'] || keys['ArrowDown']) dy = 1;
        if (keys['KeyA'] || keys['ArrowLeft']) dx = -1;
        if (keys['KeyD'] || keys['ArrowRight']) dx = 1;

        // 归一化向量
        if (dx !== 0 || dy !== 0) {
            const length = Math.sqrt(dx * dx + dy * dy);
            dx /= length;
            dy /= length;
            this.x += dx * currentSpeed;
            this.y += dy * currentSpeed;
            
            // 计算朝向
            this.angle = Math.atan2(mouse.y + camera.y - this.y, mouse.x + camera.x - this.x);
        } else {
             // 即使不移动，也要看鼠标
             this.angle = Math.atan2(mouse.y + camera.y - this.y, mouse.x + camera.x - this.x);
        }

        // 攻击
        if ((keys['Space'] || mouse.down) && this.attackTimer <= 0 && !this.holdingItem) {
            this.attacking = true;
            this.attackTimer = 20;
            AudioSys.playSword();
        }

        if (this.attackTimer > 0) {
            this.attackTimer--;
            if (this.attackTimer < 10) this.attacking = false;
        }

        // 究极手互动 (E键)
        if (keys['KeyE']) {
            keys['KeyE'] = false; // 防止连续触发
            if (this.holdingItem) {
                // 放下
                this.holdingItem = null;
                AudioSys.playUltrahand();
            } else {
                // 尝试抓取
                let closest = null;
                let minDist = 60;
                objects.forEach(obj => {
                    const dist = Math.hypot(obj.x - this.x, obj.y - this.y);
                    if (dist < minDist) {
                        closest = obj;
                        minDist = dist;
                    }
                });
                if (closest) {
                    this.holdingItem = closest;
                    AudioSys.playUltrahand();
                }
            }
        }

        // 如果抓着物体，物体跟随
        if (this.holdingItem) {
            const holdDist = 40;
            this.holdingItem.x = this.x + Math.cos(this.angle) * holdDist;
            this.holdingItem.y = this.y + Math.sin(this.angle) * holdDist;
            this.holdingItem.vx = 0;
            this.holdingItem.vy = 0;
        }

        // 边界限制 (简单版)
        if(this.x < 0) this.x = 0;
        if(this.y < 0) this.y = 0;
        if(this.x > 2000) this.x = 2000;
        if(this.y > 2000) this.y = 2000;
    }

    draw() {
        // 绘制林克
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);

        // 身体
        ctx.beginPath();
        ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
        ctx.fillStyle = this.color;
        ctx.fill();
        ctx.strokeStyle = '#1e8449';
        ctx.lineWidth = 2;
        ctx.stroke();

        // 剑 (攻击时显示)
        if (this.attacking) {
            ctx.beginPath();
            ctx.arc(0, 0, 40, -Math.PI / 4, Math.PI / 4);
            ctx.lineWidth = 10;
            ctx.strokeStyle = '#ecf0f1';
            ctx.stroke();
            // 剑光
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.lineWidth = 15;
            ctx.stroke();
        } 
        // 平时显示的剑
        else if (!this.holdingItem) {
             ctx.fillStyle = '#bdc3c7';
             ctx.fillRect(10, -3, 20, 6);
        }

        // 究极手连线效果
        if (this.holdingItem) {
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(30, 0);
            ctx.strokeStyle = '#4bdfff'; // 佐纳乌绿光
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.stroke();
            ctx.setLineDash([]);
        }

        ctx.restore();

        // 绘制精力轮 (只在非满时显示)
        if (this.stamina < this.maxStamina) {
            ctx.beginPath();
            ctx.arc(this.x - 15, this.y - 25, 5, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(0,0,0,0.5)';
            ctx.fill();
            
            ctx.beginPath();
            ctx.arc(this.x - 15, this.y - 25, 5, 0, (Math.PI * 2) * (this.stamina / this.maxStamina));
            ctx.fillStyle = '#00ff00';
            ctx.lineTo(this.x - 15, this.y - 25);
            ctx.fill();
        }
    }
}

class Enemy {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.radius = 18;
        this.speed = 1.5;
        this.color = '#e74c3c'; // 波克布林红
        this.health = 3;
        this.hitTimer = 0;
        this.knockback = {x:0, y:0};
    }

    update() {
        if (this.hitTimer > 0) {
            this.hitTimer--;
            this.x += this.knockback.x;
            this.y += this.knockback.y;
            this.knockback.x *= 0.8;
            this.knockback.y *= 0.8;
        } else {
            // 简单的追踪AI
            const dist = Math.hypot(player.x - this.x, player.y - this.y);
            if (dist < 400 && dist > 20) { // 视野范围内
                const angle = Math.atan2(player.y - this.y, player.x - this.x);
                this.x += Math.cos(angle) * this.speed;
                this.y += Math.sin(angle) * this.speed;
            }
            
            // 攻击玩家检测
            if (dist < this.radius + player.radius) {
                if (player.health > 0 && Math.random() < 0.05) {
                    player.health--;
                    AudioSys.playHit();
                    updateHearts();
                    // 简单的反弹
                    const angle = Math.atan2(player.y - this.y, player.x - this.x);
                    player.x += Math.cos(angle) * 30;
                    player.y += Math.sin(angle) * 30;
                }
            }
        }
    }

    takeDamage(dx, dy) {
        this.health--;
        this.hitTimer = 10;
        this.knockback = { x: dx * 10, y: dy * 10 };
        AudioSys.playHit();
    }

    draw() {
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fillStyle = this.hitTimer > 0 ? '#fff' : this.color;
        ctx.fill();
        
        // 眼睛
        ctx.fillStyle = 'white';
        ctx.beginPath();
        ctx.arc(this.x - 5, this.y - 5, 4, 0, Math.PI*2);
        ctx.arc(this.x + 5, this.y - 5, 4, 0, Math.PI*2);
        ctx.fill();
        ctx.fillStyle = 'black';
        ctx.beginPath();
        ctx.arc(this.x - 5, this.y - 5, 1, 0, Math.PI*2);
        ctx.arc(this.x + 5, this.y - 5, 1, 0, Math.PI*2);
        ctx.fill();
        
        // 血条
        if (this.health < 3) {
            ctx.fillStyle = 'red';
            ctx.fillRect(this.x - 15, this.y - 30, 30, 5);
            ctx.fillStyle = '#00ff00';
            ctx.fillRect(this.x - 15, this.y - 30, 30 * (this.health / 3), 5);
        }
    }
}

class ZonaiObject {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.width = 30;
        this.height = 30;
        this.color = '#7f8c8d'; // 石头色
    }
    
    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.fillStyle = '#4bdfff'; // 佐纳乌光
        ctx.globalAlpha = 0.3;
        ctx.fillRect(-this.width/2 - 2, -this.height/2 - 2, this.width + 4, this.height + 4);
        ctx.globalAlpha = 1;
        
        ctx.fillStyle = '#34495e';
        ctx.fillRect(-this.width/2, -this.height/2, this.width, this.height);
        
        // 纹路
        ctx.strokeStyle = '#4bdfff';
        ctx.beginPath();
        ctx.moveTo(-this.width/2, -this.height/2);
        ctx.lineTo(this.width/2, this.height/2);
        ctx.stroke();
        ctx.restore();
    }
}

class Particle {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.life = 1.0;
        this.vx = (Math.random() - 0.5) * 5;
        this.vy = (Math.random() - 0.5) * 5;
    }
    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.life -= 0.05;
    }
    draw() {
        ctx.globalAlpha = this.life;
        ctx.fillStyle = '#f1c40f';
        ctx.fillRect(this.x, this.y, 5, 5);
        ctx.globalAlpha = 1.0;
    }
}

/**
 * 游戏主逻辑
 */
const camera = new Camera();
let player;
let enemies = [];
let objects = [];
let particles = [];
let decoration = []; // 草地装饰

function initGame() {
    player = new Player(400, 300);
    enemies = [];
    objects = [];
    decoration = [];
    
    // 生成装饰物 (草/花)
    for(let i=0; i<100; i++) {
        decoration.push({
            x: Math.random() * 2000,
            y: Math.random() * 2000,
            size: Math.random() * 5 + 2,
            color: Math.random() > 0.5 ? '#58d68d' : '#52be80'
        });
    }

    // 生成敌人
    for(let i=0; i<10; i++) {
        enemies.push(new Enemy(Math.random() * 1800 + 100, Math.random() * 1800 + 100));
    }
    
    // 生成佐纳乌物体
    for(let i=0; i<5; i++) {
        objects.push(new ZonaiObject(Math.random() * 1800 + 100, Math.random() * 1800 + 100));
    }
    
    updateHearts();
    gameRunning = true;
    requestAnimationFrame(gameLoop);
}

function updateHearts() {
    heartsContainer.innerHTML = '';
    for(let i=0; i<player.maxHealth; i++) {
        const span = document.createElement('span');
        span.className = 'heart';
        span.innerHTML = i < player.health ? '❤' : '♡';
        heartsContainer.appendChild(span);
    }
    if (player.health <= 0) {
        alert("游戏结束！林克倒下了。");
        location.reload();
    }
}

function drawBackground() {
    // 绘制地面
    ctx.fillStyle = '#63a940';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    ctx.save();
    ctx.translate(-camera.x, -camera.y);
    
    // 绘制世界边界
    ctx.strokeStyle = '#fff';
    ctx.strokeRect(0,0, 2000, 2000);
    
    // 绘制装饰物
    decoration.forEach(d => {
        ctx.fillStyle = d.color;
        ctx.beginPath();
        ctx.arc(d.x, d.y, d.size, 0, Math.PI*2);
        ctx.fill();
    });
    
    // 绘制天空岛阴影 (模拟TotK特色)
    const time = Date.now() * 0.0001;
    ctx.fillStyle = 'rgba(0,0,0,0.1)';
    ctx.beginPath();
    ctx.ellipse(1000 + Math.sin(time)*200, 1000 + Math.cos(time)*200, 300, 200, 0, 0, Math.PI*2);
    ctx.fill();
    
    ctx.restore();
}

function gameLoop(timestamp) {
    if (!gameRunning) return;
    
    const deltaTime = timestamp - lastTime;
    lastTime = timestamp;

    ctx.clearRect(0, 0, canvas.width, canvas.height);

    camera.follow(player);
    drawBackground();

    ctx.save();
    ctx.translate(-camera.x, -camera.y);

    // 更新与绘制 物体
    objects.forEach(obj => obj.draw());

    // 更新与绘制 敌人
    enemies.forEach((enemy, index) => {
        enemy.update();
        enemy.draw();
        
        // 玩家攻击检测
        if (player.attacking) {
            // 计算攻击扇区或简单距离
            const dist = Math.hypot(player.x - enemy.x, player.y - enemy.y);
            const angleToEnemy = Math.atan2(enemy.y - player.y, enemy.x - player.x);
            // 简单的角度差检查，确保是面向敌人攻击
            let angleDiff = angleToEnemy - player.angle;
            // 规范化角度
            while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
            while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
            
            if (dist < 60 && Math.abs(angleDiff) < 1.0) {
                if (enemy.hitTimer === 0) {
                    enemy.takeDamage(Math.cos(player.angle), Math.sin(player.angle));
                    // 产生粒子
                    for(let i=0; i<5; i++) {
                        particles.push(new Particle(enemy.x, enemy.y));
                    }
                }
            }
        }
        
        // 究极手物体攻击
        if (player.holdingItem) {
             const dist = Math.hypot(player.holdingItem.x - enemy.x, player.holdingItem.y - enemy.y);
             if (dist < 30 && enemy.hitTimer === 0) {
                 enemy.takeDamage(Math.cos(player.angle), Math.sin(player.angle));
             }
        }
    });
    
    // 移除死掉的敌人
    enemies = enemies.filter(e => e.health > 0);

    // 粒子特效
    particles.forEach((p, i) => {
        p.update();
        p.draw();
        if (p.life <= 0) particles.splice(i, 1);
    });

    player.update();
    player.draw();

    ctx.restore();

    requestAnimationFrame(gameLoop);
}

/**
 * 输入监听
 */
window.addEventListener('keydown', e => keys[e.code] = true);
window.addEventListener('keyup', e => keys[e.code] = false);

canvas.addEventListener('mousemove', e => {
    const rect = canvas.getBoundingClientRect();
    mouse.x = e.clientX - rect.left;
    mouse.y = e.clientY - rect.top;
});

canvas.addEventListener('mousedown', () => mouse.down = true);
canvas.addEventListener('mouseup', () => mouse.down = false);

// 修复后的事件监听
document.getElementById('startBtn').addEventListener('click', () => {
    startScreen.style.display = 'none'; // 这里不会再报错了
    AudioSys.init(); // 初始化音频
    AudioSys.startBGM(); // 开始播放程序化背景音
    initGame();
});

</script>
</body>
</html>